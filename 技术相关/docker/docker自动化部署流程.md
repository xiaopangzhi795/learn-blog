<a name="H1KcW"></a>
# 前置准备
1. 项目需要运行的环境
1. 需要运行的系统代码&代码仓库权限
1. 运行脚本

<a name="ajwVj"></a>
# 编写代码&脚本(可参考geek-ksp代码中的脚本）

1. 为自己系统编写一个启动脚本。比如java的opts参数，spring boot的启动参数等。脚本可包含（环境变量，启动后的检查，应用启动脚本）
1. 配置maven，系统在编译之后，编译的产物在哪里，要有明确的位置，让脚本方便寻找。可用maven的finalName和outputDirectory标签来指定name和路径。
1. 配置文件放在方便查找的位置
1. 脚本统一放在脚本的目录下

<a name="eB97q"></a>
# 镜像制作（可参考server:v1镜像）

1. 制作系统运行的环境。比如自己需要一个centos系统，使用docker制作一个centos的系统，里面预安装自己所需的软件，创建用户名等。将镜像打包上传到镜像仓库
1. 编写dockerfile，从刚才制作的镜像中拉取
1. 设置环境变量，运行命令。将系统启动所需要的配置和脚本等拷贝到容器中

<a name="vv7lP"></a>
# 编写docker执行脚本（可参考geek-ksp系统的dockerfile-test）

1. 编写一个docker启动脚本。让devops平台，通过脚本在服务器上面自动运行docker容器。
1. 编写容器内执行脚本。docker容器启动时，只能运行一个脚本，为了方便，编写一个脚本，运行自己要运行的所有脚本。另外脚本运行结束后，docker容器就会关闭退出，所以如果脚本是后台运行的，最后需要加上 exec /bin/bash，让脚本始终在前台执行，不要退出。

<a name="CZc6f"></a>
# 使用云效进行配置流水线（可参考云效：geek-ksp流水线）

1. 设置代码源，让云效拉取代码，使用该代码进行自动化运行
1. （可选）配置代码规约扫描和跑单测，保证流水线的代码是安全可用的。
1. 编译代码，将代码编译打包
1. 构建镜像，构建一个容器镜像
1. 部署，使用docker运行脚本，在服务器启动应用

<a name="rp5Cf"></a>
# 注意事项
<a name="bNDMM"></a>
## docker容器启动后关闭问题
docker运行脚本结束后，就会关闭容器。所以需要docker容器内的执行脚本，有一条命令始终保证脚本在前台运行。该脚本是容器启动后运行的那个脚本，而不是启动docker容器的那个脚本

<a name="aY4uf"></a>
## docker容器启动后，脚本启动失败，文件夹没有权限
当使用了-v进行路径挂载之后，挂载的路径就是宿主机上面该文件创建的用户&权限。一般docker运行时，使用的是容器内的用户权限，所以是没有权限对该文件进行操作的。<br />注意：linux的权限，不看名字，只看权限id
<a name="bBQCM"></a>
### 解决方案

1. 创建一个和宿主机权限id相同的用户。使用该用户启动
1. 启动时指定用户id，就可以直接使用对应的权限进行启动
1. 在服务器内创建一个和容器内用户id相同的用户来创建文件夹，这样容器启动时就天然拥有该权限。

<a name="xR3vL"></a>
## 服务器启动成功后，debug不能用

<a name="dWhrn"></a>
### <br />
